
.. _`single sequential run`: ../SeqSim
.. _`LahnH`: https://hydpy-dev.github.io/hydpy/master/examples.html#hydpy.examples
.. _`Alpha`: https://hydpy-dev.github.io/hydpy/master/hland.html#hydpy.models.hland.hland_control.Alpha
.. _`main.oda`: main.oda
.. _`algorithm.xml`: algorithm.xml
.. _`model.xml`: model.xml
.. _`OpenDA`: https://www.openda.org/
.. _`HydPyOpenDABBModelWrapper`: ./../../../extensions/HydPyOpenDABBModelWrapper
.. _`HydPy server`: https://hydpy-dev.github.io/hydpy/master/servertools.html#hydpy.exe.servertools.HydPyServer
.. _`UZ`: https://hydpy-dev.github.io/hydpy/master/hland.html#hydpy.models.hland.hland_states.UZ

Perform an ensemble of sequential runs
--------------------------------------

This example extends the `single sequential run`_ example.  Again, we  perform
sequential runs on the "Lahn 1" headwater catchment of the `LahnH`_ project.  However,
this time we handle three sequential runs in parallel, each one with different values
for parameter `Alpha`_.  The file `main.oda`_ selects the `SequentialEnsembleSimulation`
algorithm which, due to the settings of file `algorithm.xml`_, generates different
initial values of `Alpha`_ for each ensemble run showing autocorrelation as defined by
the AR(1) parameters in file `model.xml`_.

This example is the first one where the simulation results depend on random numbers
generated by `OpenDA`_.  Hence, we have to run `OpenDA`_ first, before being able to
calculate the results on our own:

>>> from hydpy import HydPy, pub, print_values, run_subprocess
>>> pub.options.printprogress = False
>>> pub.options.reprdigits = 4
>>> _ = run_subprocess("oda_run_batch main.oda", verbose=False)

We now load the three simulation results into the dictionary `ext_sims` and show the
first five values of each series:

>>> import runpy
>>> results = runpy.run_path("results/final.py")
>>> ext_sims = {}
>>> for idx in range(1, 4):
...     ext_sims[idx] = results[f"pred_f_{idx-1}"][:, 0]
...     print(f"sim {idx}:", end=" ")
...     print_values(ext_sims[idx][:5])
sim 1: 23.4392, 9.1479, 7.1699, 6.8803, 6.5951
sim 2: 11.5159, 8.5172, 7.6563, 7.2729, 7.1055
sim 3: 16.2495, 9.4814, 7.6216, 7.1185, 6.85

To reproduce these results, we need to know the `Alpha`_ values of the different
ensemble members at the different simulation time steps.  These are available in the
member-specific subdirectories of folder *results*, which have been created
automatically due to the *modelFactory* settings in file `model.xml`_.  We now read the
three `Alpha`_ time series into the dictionary *ext_alphas*:

>>> import numpy
>>> ext_alphas = {}
>>> for idx in range(1, 4):
...     with open(f"results/instance{idx}/ArmaNoiseModel-log.txt") as logfile:
...         deltas = [float(noise) for noise in logfile.readlines()[3::2]]
...         alphas = 2.0 + numpy.cumsum(deltas)
...         ext_alphas[idx] = alphas
...     print(f"sim {idx}:", end=" ")
...     print_values(alphas[:5])
sim 1: 2.5362, 2.7424, 2.8217, 2.8522, 2.8639
sim 2: 1.3418, 1.0886, 0.9912, 0.9538, 0.9394
sim 3: 1.8871, 1.8437, 1.827, 1.8206, 1.8181

To understand the printed results, inspect for example the first simulation time step,
where the initial storage content of `UZ`_ is the same for all three members. Here, the
highest value of `Alpha`_ (2.54) results in the highest discharge value (23.29).

Now we use these `Alpha`_ values to show that we can reproduce the simulated discharge
series "by hand" (the code is a little complex, but in essence, we just calculate the
discharge series one after another and adjust the `Alpha`_ value between subsequent
timesteps):

>>> import os
>>> os.chdir("../../hydpy_projects")
>>> hp = HydPy("LahnH")
>>> pub.timegrids = "1996-01-01", "1996-02-10", "1d"
>>> hp.prepare_everything()
>>> initialconditions = hp.conditions
>>> os.chdir("../openda_projects/SeqEnsSim")
>>> int_sims = {}
>>> for idx, alphas in ext_alphas.items():
...     hp.conditions = initialconditions
...     pub.timegrids.sim.firstdate = "1996-01-01"
...     pub.timegrids.sim.lastdate = "1996-01-02"
...     for alpha in alphas:
...         model = hp.elements.land_lahn_1.model
...         model.parameters.control.alpha(alpha)
...         hp.simulate()
...         pub.timegrids.sim.firstdate += "1d"
...         pub.timegrids.sim.lastdate += "1d"
...     int_sims[idx] = hp.nodes.lahn_1.sequences.sim.series.copy()
...     print(f"sim {idx}:", end=" ")
...     print_values(int_sims[idx][:5])
sim 1: 23.4392, 9.1479, 7.1699, 6.8803, 6.5951
sim 2: 11.5159, 8.5172, 7.6563, 7.2729, 7.1055
sim 3: 16.2495, 9.4814, 7.6216, 7.1185, 6.85

Both simulation results of the `OpenDA` based and the "pure Python" approach are
identical not only the first five days but for the complete simulation period of fourty
days:

>>> for idx in range(1, 4):
...     print(f"sim {idx}:", end=" ")
...     numpy.all(numpy.round(int_sims[idx] - ext_sims[idx], 6) == 0.0)
sim 1: True
sim 2: True
sim 3: True

Note that the `HydPyOpenDABBModelWrapper`_ does not initialise three separate
`HydPy server`_ instances. Instead, it relies on a single server instance and its
"bookmarking" feature, related to query parameter *id*.  However, handling multiple
server instances would be a helpful thing to do, allowing to execute multiple
simulations at the same time.
