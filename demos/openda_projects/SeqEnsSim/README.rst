
.. _`single sequential run`: ../SeqSim
.. _`LahnH`: https://hydpy-dev.github.io/hydpy/examples.html#hydpy.core.examples
.. _`Alpha`: https://hydpy-dev.github.io/hydpy/hland.html#hydpy.models.hland.hland_control.Alpha
.. _`main.oda`: main.oda
.. _`algorithm.xml`: algorithm.xml
.. _`model.xml`: model.xml
.. _`HydPyOpenDABBModelWrapper`: ./../../../extensions/HydPyOpenDABBModelWrapper
.. _`HydPy server`: https://hydpy-dev.github.io/hydpy/servertools.html#hydpy.exe.servertools.HydPyServer
.. _`UZ`: https://hydpy-dev.github.io/hydpy/hland.html#hydpy.models.hland.hland_states.UZ

Perform an ensemble of sequential runs
--------------------------------------

This example extends the `single sequential run`_ example.  Again, we
perform sequential runs on the "Lahn 1" headwater catchment of the
`LahnH`_ project.  However, this time we handle three sequential runs
in parallel, each one with different values for parameter `Alpha`_.
File `main.oda`_ selects the `SequentialEnsembleSimulation` algorithm
which, due to the settings of file `algorithm.xml`_, generates different
initial values of `Alpha`_ for each ensemble run showing autocorrelation
as defined by the AR(1) parameters in file `model.xml`_.

This example is the first one where the simulation results depend on
random numbers generated by `OpenDA`_.  Hence, we have to run `OpenDA`_
first, before beeing able to calculate the same results on our own:

>>> from hydpy import HydPy, pub, print_values, run_subprocess
>>> pub.options.printprogress = False
>>> pub.options.reprdigits = 6
>>> run_subprocess('oda_run_batch main.oda', verbose=False)

We now load the three simulation results into dictionary `ext_sim` and
show the first five values of each series:

>>> import runpy
>>> results = runpy.run_path('results/final.py')
>>> ext_sims = {}
>>> for idx in range(1, 4):
...     ext_sims[idx] = results[f'pred_f_{idx-1}'][:, 0]
...     print(f'sim {idx}:', end=' ')
...     print_values(ext_sims[idx][:5])
sim 1: 23.292242, 9.149346, 7.174979, 6.886055, 6.600641
sim 2: 11.465863, 8.503955, 7.652735, 7.274943, 7.106856
sim 3: 16.146278, 9.464293, 7.620645, 7.123824, 6.854726

To reproduce these results, we need to know the `Alpha`_ values of the
different ensemble members at the different simulation time steps.
These are available within the member specific subdirectories of folder
`results`, which have been created automatically due to the `modelFactory`
settings in file `model.xml`_.  The now read the three `Alpha`_ time
series into dictionary `ext_alphas`:

>>> import numpy
>>> ext_alphas = {}
>>> for idx in range(1, 4):
...     with open(f'results/instance{idx}/ArmaNoiseModel-log.txt') as logfile:
...         deltas = [float(noise) for noise in logfile.readlines()[3::2]]
...         alphas = 2.0 + numpy.cumsum(deltas)
...         ext_alphas[idx] = alphas
...     print(f'sim {idx}:', end=' ')
...     print_values(alphas[:5])
sim 1: 2.536154, 2.742358, 2.821664, 2.852165, 2.863895
sim 2: 1.341763, 1.088606, 0.991242, 0.953796, 0.939394
sim 3: 1.887139, 1.843733, 1.827039, 1.820619, 1.818149

To understand the printed results, inspect for example the first simulation
time step, where the storage content of `UZ`_ is still the same for all
parallel runs. Here, the highest value of `Alpha`_ (2.54) results in the
highest discharge value (23.29).

Now we use these `Alpha`_ values to show that we can reproduce the simulated
discharge series "by hand" (the code is a little complex, but in essence,
the discharge series are calculated one after another and - in each
sequential run - the `Alpha`_ value is adjusted from timestep to timestep):

>>> import os
>>> os.chdir('../../hydpy_projects')
>>> hp = HydPy('LahnH')
>>> pub.timegrids = '1996-01-01', '1996-02-10', '1d'
>>> hp.prepare_everything()
>>> initialconditions = hp.conditions
>>> os.chdir('../openda_projects/SeqEnsSim')
>>> int_sims = {}
>>> for idx, alphas in ext_alphas.items():
...     hp.conditions = initialconditions
...     pub.timegrids.sim.firstdate = '1996-01-01'
...     pub.timegrids.sim.lastdate = '1996-01-02'
...     for alpha in alphas:
...         model = hp.elements.land_lahn_1.model
...         model.parameters.control.alpha(alpha)
...         hp.doit()
...         pub.timegrids.sim.firstdate += '1d'
...         pub.timegrids.sim.lastdate += '1d'
...     int_sims[idx] = hp.nodes.lahn_1.sequences.sim.series.copy()
...     print(f'sim {idx}:', end=' ')
...     print_values(int_sims[idx][:5])
sim 1: 23.292242, 9.149346, 7.174979, 6.886055, 6.600641
sim 2: 11.465863, 8.503955, 7.652735, 7.274943, 7.106856
sim 3: 16.146278, 9.464293, 7.620645, 7.123824, 6.854726

Both simulation results of the `OpenDA` based and the "pure Python"
approach are identical not only the first five days, but for the
complete simulation period of 40 days:

>>> for idx in range(1, 4):
...     print(f'sim {idx}:', end=' ')
...     numpy.all(
...         numpy.round(int_sims[idx], 6) == numpy.round(ext_sims[idx], 6))
sim 1: True
sim 2: True
sim 3: True

Note that the `HydPyOpenDABBModelWrapper`_ does not initialise three
separate `HydPy server`_ instances. Instead, it relies on a single
server instance and its "bookmarking" feature, related to query parameter
*id*.  However, handling multiple server instances would be a fine thing
to do, as it would allow for a really parallel execution of the simulation
runs.

